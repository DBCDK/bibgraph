// Generated by CoffeeScript 1.6.2
(function() {
  var $graph, addMenu, backlinks, boxPadding, boxSize, canvas, clear, clickTime, ctx, decrease, draw, edgeTry, edges, existing, expand, findEdges, force, forceTick, graphLoading, hideMenuItems, increase, initDraw, klynger, links, menuItems, menuSize, movingKlynge, movingMouseMove, movingX, movingX0, movingY, movingY0, nNodes, nodes, nodesOld, pick, pin, qp, recur, requestKlynge, requestKlyngeOld, reset, root, search, showMenuItems, start, startDrawing, stopMoving, update, updateKlynge, updateOld, _pickN,
    __slice = [].slice;

  nNodes = 50;

  edgeTry = 10;

  boxSize = 60;

  boxPadding = 4;

  menuSize = 40;

  backlinks = 4;

  recur = 18;

  klynger = {};

  nodes = [];

  links = [];

  root = void 0;

  graphLoading = false;

  qp = window.qp || {};

  qp.prngSeed = Date.now();

  qp.prng = function(n) {
    return qp.prngSeed = (1664525 * (n === void 0 ? qp.prngSeed : n) + 1013904223) | 0;
  };

  qp.strhash = function(s) {
    var hash, i;

    hash = 5381;
    i = s.length;
    while (i) {
      hash = (hash * 31 + s.charCodeAt(--i)) | 0;
    }
    return hash;
  };

  qp.intToColor = function(i) {
    return "#" + ((i & 0xffffff) + 0x1000000).toString(16).slice(1);
  };

  qp.hashColorLight = function(s) {
    return qp.intToColor(0xe0e0e0 | qp.prng(1 + qp.strhash(s)));
  };

  qp.hashColorDark = function(s) {
    return qp.intToColor(0x7f7f7f & qp.prng(qp.strhash(s)));
  };

  qp.log = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return typeof qp._log === "function" ? qp._log.apply(qp, [document.title].concat(__slice.call(args))) : void 0;
  };

  clickTime = 0;

  movingKlynge = void 0;

  movingX = 0;

  movingY = 0;

  movingX0 = 0;

  movingY0 = 0;

  pin = function(klynge) {
    var pinned;

    pinned = !klynge.pinned;
    klynge.pinned = pinned;
    klynge.fixed = pinned;
    if (pinned) {
      return ($(klynge.div)).addClass("pinned");
    } else {
      return ($(klynge.div)).removeClass("pinned");
    }
  };

  increase = function(klynge) {
    klynge.children += 3;
    return update();
  };

  decrease = function(klynge) {
    if (klynge.children >= 3) {
      klynge.children -= 3;
    }
    return update();
  };

  clear = function(klynge) {
    klynge.children = 0;
    return update();
  };

  expand = function(klynge) {
    recur = 10;
    root = klynge.klynge;
    klynger = {};
    klynger[root] = klynge;
    klynge.children = 6;
    nodes = [];
    return update();
  };

  menuItems = {
    "0": {
      x: -menuSize * 1.2,
      y: menuSize * .2,
      fn: clear
    },
    "-": {
      x: -menuSize * .8,
      y: -menuSize * .8,
      fn: decrease
    },
    "p": {
      x: boxSize / 2 - menuSize / 2,
      y: -menuSize * 1.2,
      fn: pin
    },
    "+": {
      x: boxSize - menuSize * .2,
      y: -menuSize * .8,
      fn: increase
    },
    "*": {
      x: boxSize + menuSize * .2,
      y: menuSize * .2,
      fn: expand
    }
  };

  showMenuItems = function() {
    var item, name, _results;

    if (!movingKlynge) {
      return;
    }
    _results = [];
    for (name in menuItems) {
      item = menuItems[name];
      _results.push((function(name, item) {
        var $div;

        $div = $("<div><div>" + name + "</div></div>");
        $div.addClass("bibgraphMenuItem");
        $div.css({
          left: movingKlynge.x + item.x,
          top: movingKlynge.y + item.y,
          width: menuSize,
          height: menuSize
        });
        ($("#graph")).append($div);
        $div.on("mouseup", function() {
          if (item.fn) {
            item.fn(movingKlynge);
          }
          return console.log("enable", name);
        });
        $div.on("mouseover", function() {
          return $div.addClass("active");
        });
        return $div.on("mouseout", function() {
          return $div.removeClass("active");
        });
      })(name, item));
    }
    return _results;
  };

  hideMenuItems = function() {
    return $(".bibgraphMenuItem").remove();
  };

  addMenu = function($elem, klynge) {
    var elem;

    elem = $elem[0];
    return elem.addEventListener("mousedown", function(e) {
      if (movingKlynge) {
        return;
      }
      clickTime = Date.now();
      e.preventDefault();
      movingKlynge = klynge;
      $elem.addClass("active");
      movingX0 = movingX = e.x;
      movingY0 = movingY = e.y;
      klynge.fixed = true;
      showMenuItems();
      return true;
    });
  };

  stopMoving = function(e) {
    var dx, dy;

    e.preventDefault();
    hideMenuItems();
    if (movingKlynge === void 0) {
      return;
    }
    console.log(movingKlynge);
    movingKlynge.fixed = movingKlynge.pinned;
    ($(movingKlynge.div)).removeClass("active");
    dx = movingX - movingX0;
    dy = movingY - movingY0;
    if (dx * dx + dy * dy < boxSize * boxSize / 4 && Date.now() - clickTime < 300) {
      increase(movingKlynge);
    }
    movingKlynge = void 0;
    return true;
  };

  movingMouseMove = function(e) {
    var dx, dy, klynge, menuRadius;

    if (!movingKlynge) {
      return;
    }
    dx = movingX - movingX0;
    dy = movingY - movingY0;
    menuRadius = menuSize + boxSize * Math.sqrt(2);
    if (dx * dx + dy * dy > menuRadius * menuRadius) {
      hideMenuItems();
    }
    console.log("xxxx", dx * dx + dy * dy < boxSize * boxSize / 4 && Date.now() - clickTime < 1000);
    klynge = movingKlynge;
    e.preventDefault();
    dx = e.x - movingX;
    dy = e.y - movingY;
    klynge.x += dx;
    klynge.y += dy;
    klynge.px += dx;
    klynge.py += dy;
    movingX += dx;
    movingY += dy;
    force.start();
    return true;
  };

  $(function() {
    window.addEventListener("mousemove", movingMouseMove);
    window.addEventListener("mouseup", stopMoving);
    return window.addEventListener("mouseleave", stopMoving);
  });

  ctx = void 0;

  canvas = void 0;

  nodesOld = [];

  edges = [];

  force = void 0;

  findEdges = function() {
    var a, b, i, idx, klynge, _i, _j, _k, _len, _len1, _ref, _results;

    for (i = _i = 0, _ref = nodesOld.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      nodesOld[i].index = i;
    }
    idx = {};
    for (_j = 0, _len = nodesOld.length; _j < _len; _j++) {
      klynge = nodesOld[_j];
      idx[klynge.klynge] = klynge.index;
    }
    edges = [];
    _results = [];
    for (_k = 0, _len1 = nodesOld.length; _k < _len1; _k++) {
      a = nodesOld[_k];
      _results.push((function() {
        var _l, _len2, _ref1, _results1;

        _ref1 = a.adhl.slice(0, edgeTry);
        _results1 = [];
        for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
          b = _ref1[_l];
          if (typeof idx[b.klynge] === "number") {
            _results1.push(edges.push({
              source: a.index,
              target: idx[b.klynge]
            }));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  startDrawing = function() {
    findEdges();
    return draw();
  };

  initDraw = function() {
    window.force = force = d3.layout.force();
    force.size([window.innerWidth, window.innerHeight]);
    force.on("tick", forceTick);
    force.charge(-400);
    force.linkDistance(150);
    force.linkStrength(0.3);
    return force.gravity(0.1);
  };

  draw = function() {
    var $canvas, $div, h, klynge, size, w, _i, _j, _len, _len1, _ref;

    document.getElementById("graph").innerHTML = "";
    $canvas = $("<canvas></canvas>");
    $("#graph").append($canvas);
    canvas = $canvas[0];
    ctx = canvas.getContext("2d");
    $canvas.css({
      position: "absolute",
      top: 0,
      left: 0
    });
    w = window.innerWidth;
    h = window.innerHeight;
    ctx.width = canvas.width = w;
    ctx.height = canvas.height = h;
    canvas.style.width = w + "px";
    canvas.style.heiht = h + "px";
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      klynge = nodes[_i];
      klynge.label = String(klynge.title).replace("&amp;", "&").replace(/&#([0-9]*);/g, function(_, n) {
        return String.fromCharCode(n);
      });
      klynge.label = "";
    }
    _ref = nodes.reverse();
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      klynge = _ref[_j];
      klynge.title = "" + klynge.title;
      $div = $("<div>" + klynge.title + "</div>");
      $div.addClass("bibgraphBox");
      $div.data("klynge", klynge);
      $div.css({
        width: boxSize - 2 * boxPadding,
        color: qp.hashColorDark(klynge.title),
        padding: boxPadding,
        borderRadius: boxPadding
      });
      $("#graph").append($div);
      size = 12;
      addMenu($div, klynge);
      while ($div.height() > boxSize && size > 8) {
        --size;
        $div.css({
          fontSize: size
        });
      }
      $div.css({
        height: boxSize
      });
      klynge.div = $div[0];
    }
    force.nodes(nodes);
    force.links(links);
    return force.start();
  };

  forceTick = function() {
    var klynge, link, _i, _j, _len, _len1;

    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      klynge = nodes[_i];
      klynge.div.style.top = klynge.y + "px";
      klynge.div.style.left = klynge.x + "px";
    }
    ctx.lineWidth = 0.3;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
      link = links[_j];
      ctx.moveTo(link.source.x + boxSize / 2, link.source.y + boxSize / 2);
      ctx.lineTo(link.target.x + boxSize / 2, link.target.y + boxSize / 2);
    }
    return ctx.stroke();
  };

  requestKlynge = function(klyngeId) {
    var klynge;

    if (klynger[klyngeId]) {
      klynge = klynger[klyngeId];
      if (!klynge.added) {
        nodes.push(klynge);
      }
      klynge.added = true;
      return;
    }
    if (graphLoading) {
      return;
    }
    graphLoading = true;
    return $.get("klynge/" + klyngeId, function(klynge) {
      var _ref;

      if (typeof klynge !== "object") {
        klynge = {
          raw: klynge
        };
      }
      if (recur > 0) {
        klynge.children = 3;
        --recur;
      } else {
        klynge.children = 0;
      }
      klynger[klyngeId] = klynge;
      graphLoading = false;
      if (klynge.faust) {
        updateKlynge(klynge);
      }
      if ((_ref = klynge.adhl) != null) {
        _ref.sort(function(a, b) {
          return b.count * b.count / b.klyngeCount - a.count * a.count / a.klyngeCount;
        });
      }
      return update();
    });
  };

  updateKlynge = function(klynge) {
    if (!klynge.faust) {
      return;
    }
    return $.get("faust/" + klynge.faust[0], function(faust) {
      klynge.title = faust.title;
      return update();
    });
  };

  update = function() {
    var child, children, full, i, klynge, _, _i, _j, _k, _len, _len1, _len2, _ref;

    i = 0;
    for (_ in klynger) {
      klynge = klynger[_];
      klynge.added = false;
    }
    nodes = [klynger[root]];
    klynger[root].added = true;
    links = [];
    while (i < nodes.length) {
      klynge = nodes[i];
      if (klynge.adhl) {
        children = klynge.adhl.slice(0, klynge.children || 0);
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          requestKlynge(child.klynge);
        }
      }
      ++i;
    }
    for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
      klynge = nodes[_j];
      full = true;
      if (klynge.adhl) {
        _ref = klynge.adhl.slice(0, (klynge.children || 0) + backlinks);
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          child = _ref[_k];
          child = klynger[child.klynge];
          if (child != null ? child.added : void 0) {
            links.push({
              source: klynge,
              target: child
            });
          } else {
            full = false;
          }
        }
      }
    }
    for (_ in klynger) {
      klynge = klynger[_];
      if (!klynge.added) {
        klynge.children = 0;
      }
    }
    return draw();
  };

  reset = function() {
    var existing, _pickN;

    existing = {};
    _pickN = 0;
    return window.nodesOld = nodesOld = [];
  };

  start = function(done) {
    if (nodesOld.length) {
      expand(done);
    }
    return updateOld();
  };

  _pickN = 1;

  pick = function(arr) {
    _pickN = qp.prng(_pickN);
    return arr[(_pickN & 0x7fffffff) % arr.length];
  };

  existing = {};

  expand = function(done) {
    var child, i, klynge, _i, _j, _k, _len, _len1, _ref;

    if (nodesOld.length >= nNodes) {
      return typeof done === "function" ? done() : void 0;
    }
    for (_i = 0, _len = nodesOld.length; _i < _len; _i++) {
      klynge = nodesOld[_i];
      existing[klynge.klynge] = true;
    }
    for (i = _j = 0; _j <= 20; i = ++_j) {
      klynge = nodesOld[Math.random() * nodesOld.length | 0];
      klynge = pick(nodesOld);
      _ref = klynge.adhl;
      for (_k = 0, _len1 = _ref.length; _k < _len1; _k++) {
        child = _ref[_k];
        if (!existing[child.klynge]) {
          existing[child.klynge] = true;
          return requestKlyngeOld(child.klynge, function() {
            return expand(done);
          });
        }
      }
    }
  };

  requestKlyngeOld = function(klyngeId, done) {
    return $.get("klynge/" + klyngeId, function(klynge) {
      var _ref;

      if (!klynge.faust) {
        return typeof done === "function" ? done() : void 0;
      }
      nodesOld.push(klynge);
      if ((_ref = klynge.adhl) != null) {
        _ref.sort(function(a, b) {
          return b.count * b.count / b.klyngeCount - a.count * a.count / a.klyngeCount;
        });
      }
      return $.get("faust/" + klynge.faust[0], function(faust) {
        klynge.title = faust.title;
        updateOld();
        return typeof done === "function" ? done() : void 0;
      });
    });
  };

  $graph = void 0;

  $(function() {
    return $graph = $("#graph");
  });

  updateOld = function() {
    var klynge, _i, _len, _results;

    $graph.empty();
    nodesOld = nodesOld.filter(function(klynge) {
      return klynge.adhl;
    });
    _results = [];
    for (_i = 0, _len = nodesOld.length; _i < _len; _i++) {
      klynge = nodesOld[_i];
      _results.push($graph.append("<span> &nbsp; " + klynge.title + " " + klynge.count + "</span>"));
    }
    return _results;
  };

  search = function() {
    var query;

    reset();
    query = ($("#query")).css({
      display: "none"
    }).val();
    location.hash = query;
    nodesOld = [];
    qp.log("search", query);
    return $.get("search/" + query, function(result) {
      ($("#query")).css({
        display: "inline"
      }).val("");
      return async.map(result, function(faust, done) {
        return $.get("faust/" + faust, function(faust) {
          if (faust != null ? faust.klynge : void 0) {
            return requestKlyngeOld(faust != null ? faust.klynge : void 0, done);
          } else {
            return done();
          }
        });
      }, function() {
        var klynge, max, _i, _len;

        max = {
          count: 0
        };
        for (_i = 0, _len = nodesOld.length; _i < _len; _i++) {
          klynge = nodesOld[_i];
          if (max.count <= klynge.count) {
            max = klynge;
          }
        }
        nodesOld = [max];
        console.log("root:", max);
        initDraw();
        root = max.klynge;
        return requestKlynge(root);
      });
    });
  };

  $(function() {
    ($("#search")).on("submit", function() {
      search();
      return false;
    });
    if (location.hash) {
      ($("#query")).val(location.hash.slice(1));
      search();
    }
    return ($("#search")).focus();
  });

}).call(this);
