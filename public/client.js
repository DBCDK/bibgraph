// Generated by CoffeeScript 1.6.2
(function() {
  var $touched, boxPadding, boxSize, canvas, ctx, doEnd, doMove, doStart, draw, force, forceTick, graphLoading, handleTouch, initDraw, klyngeWalk, klynger, links, loadKlynge, makeLinks, nodes, pinned, px0, py0, qp, requestKlynge, salt, startTime, touchedKlynge, update, updateKlynge, walkDepth, wasPinned, x0, y0,
    __slice = [].slice;

  boxSize = 60;

  boxPadding = 4;

  walkDepth = 80;

  klynger = {};

  nodes = [];

  links = [];

  pinned = {};

  qp = window.qp = window.qp || {};

  qp.prngSeed = Date.now();

  qp.prng = function(n) {
    return qp.prngSeed = (1664525 * (n === void 0 ? qp.prngSeed : n) + 1013904223) | 0;
  };

  qp.strHash = function(s) {
    var hash, i;

    hash = 5381;
    i = s.length;
    while (i) {
      hash = (hash * 31 + s.charCodeAt(--i)) | 0;
    }
    return hash;
  };

  qp.intToColor = function(i) {
    return "#" + ((i & 0xffffff) + 0x1000000).toString(16).slice(1);
  };

  qp.hashColorLight = function(s) {
    return qp.intToColor(0xe0e0e0 | qp.prng(1 + qp.strHash(s)));
  };

  qp.hashColorDark = function(s) {
    return qp.intToColor(0x7f7f7f & qp.prng(qp.strHash(s)));
  };

  qp.log = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return typeof qp._log === "function" ? qp._log.apply(qp, [document.title].concat(__slice.call(args))) : void 0;
  };

  qp.pick = function(arr, seed) {
    return arr[Math.abs(qp.prng(seed)) % arr.length];
  };

  wasPinned = px0 = py0 = x0 = y0 = startTime = $touched = touchedKlynge = void 0;

  doStart = function(e, $elem, klynge, x, y) {
    console.log("start", $touched);
    if ($touched) {
      return;
    }
    touchedKlynge = klynge;
    px0 = touchedKlynge.px;
    py0 = touchedKlynge.py;
    $touched = $elem;
    x0 = x;
    y0 = y;
    startTime = Date.now();
    $touched.addClass("pinned");
    wasPinned = pinned[touchedKlynge.klynge];
    pinned[touchedKlynge.klynge] = true;
    touchedKlynge.fixed = true;
    e.preventDefault();
    return true;
  };

  doMove = function(e, x, y) {
    console.log("move", $touched);
    if (!$touched) {
      return;
    }
    touchedKlynge.px = px0 + x - x0;
    touchedKlynge.py = py0 + y - y0;
    force.start();
    e.preventDefault();
    return true;
  };

  doEnd = function(e, x, y) {
    var dist, dx, dy;

    console.log("end", $touched);
    if (!$touched) {
      return;
    }
    dx = x - x0;
    dy = y - y0;
    dist = Math.sqrt(dx * dx + dy * dy);
    console.log(dist, boxSize, startTime, Date.now());
    if (wasPinned && dist < boxSize && (startTime + 500) > Date.now()) {
      pinned[touchedKlynge.klynge] = false;
      touchedKlynge.fixed = false;
      $touched.removeClass("pinned");
    }
    $touched = void 0;
    e.preventDefault();
    return true;
  };

  handleTouch = function($elem, klynge) {
    return $elem.on("mousedown", function(e) {
      return doStart(e, $elem, klynge, e.screenX, e.screenY);
    });
  };

  $(function() {
    ($(window)).on("mouseup", function(e) {
      return doEnd(e, e.screenX, e.screenY);
    });
    return ($(window)).on("mousemove", function(e) {
      return doMove(e, e.screenX, e.screenY);
    });
  });

  ctx = void 0;

  canvas = void 0;

  force = void 0;

  initDraw = function() {
    var $canvas, h, w;

    window.force = force = d3.layout.force();
    force.size([window.innerWidth, window.innerHeight]);
    force.on("tick", forceTick);
    force.charge(-400);
    force.linkDistance(150);
    force.linkStrength(0.3);
    force.gravity(0.1);
    document.getElementById("graph").innerHTML = "";
    $canvas = $("<canvas></canvas>");
    $("#graph").append($canvas);
    canvas = $canvas[0];
    ctx = canvas.getContext("2d");
    $canvas.css({
      position: "absolute",
      top: 0,
      left: 0
    });
    w = window.innerWidth;
    h = window.innerHeight;
    ctx.width = canvas.width = w;
    ctx.height = canvas.height = h;
    canvas.style.width = w + "px";
    return canvas.style.heiht = h + "px";
  };

  draw = function() {
    var $div, klynge, size, _i, _len;

    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      klynge = nodes[_i];
      if (klynge.title && !klynge.div) {
        klynge.title = "" + klynge.title;
        $div = $("<div>" + klynge.title + "</div>");
        $div.addClass("bibgraphBox");
        if (pinned[klynge.klynge]) {
          $div.addClass("pinned");
        }
        $div.data("klynge", klynge);
        $div.css({
          width: boxSize - 2 * boxPadding,
          color: qp.hashColorDark(klynge.title),
          padding: boxPadding,
          borderRadius: boxPadding
        });
        $("#graph").append($div);
        size = 12;
        handleTouch($div, klynge);
        while ($div.height() > boxSize && size > 8) {
          --size;
          $div.css({
            fontSize: size
          });
        }
        $div.css({
          height: boxSize
        });
        klynge.div = $div[0];
      }
    }
    force.nodes(nodes);
    force.links(links);
    return force.start();
  };

  forceTick = function() {
    var klynge, link, _i, _j, _len, _len1;

    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      klynge = nodes[_i];
      if (klynge.div) {
        klynge.div.style.top = klynge.y + "px";
        klynge.div.style.left = klynge.x + "px";
      }
    }
    ctx.lineWidth = 0.3;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
      link = links[_j];
      if (link.source.div && link.target.div) {
        ctx.moveTo(link.source.x + boxSize / 2, link.source.y + boxSize / 2);
        ctx.lineTo(link.target.x + boxSize / 2, link.target.y + boxSize / 2);
      }
    }
    return ctx.stroke();
  };

  graphLoading = false;

  salt = 1;

  klyngeWalk = function(klyngeId, n, callback, done, salt, acc) {
    if (!acc) {
      acc = {
        arr: [],
        added: {},
        links: []
      };
    }
    if (!done) {
      done = callback;
      callback = (function() {});
    }
    if (typeof salt !== "number") {
      salt = qp.strHash(klyngeId);
    }
    callback(acc.arr, acc.links);
    if (n <= 0) {
      return done(acc.arr, acc.links);
    }
    return loadKlynge(klyngeId, function(klynge) {
      var branch, child, hash, i, _i, _j, _len, _ref;

      acc.arr.push(klynge);
      acc.added[klyngeId] = true;
      hash = salt + qp.strHash(klyngeId);
      for (i = _i = 0; _i <= 30; i = ++_i) {
        branch = qp.pick(acc.arr, hash);
        klyngeId = branch.klynge;
        if (branch.adhl) {
          _ref = branch.adhl;
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            child = _ref[_j];
            if (!acc.added[child.klynge]) {
              console.log(klyngeId, child.klynge, acc.added);
              acc.links.push([klyngeId, child.klynge]);
              return klyngeWalk(child.klynge, n - 1, callback, done, salt, acc);
            }
          }
        }
        hash = qp.prng(hash);
      }
      return done(acc.arr, acc.links);
    });
  };

  loadKlynge = function(klyngeId, callback) {
    console.log("loadKlynge", klyngeId);
    if (klynger[klyngeId]) {
      return callback(klynger[klyngeId]);
    }
    return $.get("klynge/" + klyngeId, function(klynge) {
      var _ref;

      if (typeof klynge !== "object") {
        klynge = {
          raw: klynge
        };
      }
      klynger[klyngeId] = klynge;
      if ((_ref = klynge.adhl) != null) {
        _ref.sort(function(a, b) {
          return b.count * b.count / b.klyngeCount - a.count * a.count / a.klyngeCount;
        });
      }
      if (klynge.faust) {
        updateKlynge(klynge);
      }
      return callback(klynge);
    });
  };

  updateKlynge = function(klynge) {
    if (!klynge.faust) {
      return;
    }
    return $.get("faust/" + klynge.faust[0], function(faust) {
      klynge.title = faust.title;
      return draw();
    });
  };

  makeLinks = function(links) {
    var a, b, link, linkMap, result, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;

    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      link.sort();
    }
    links = links.map(JSON.stringify);
    linkMap = {};
    for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
      link = links[_j];
      linkMap[link] = true;
    }
    links = (Object.keys(linkMap)).map(JSON.parse);
    links.filter;
    result = [];
    _ref = links.filter((function(a) {
      return klynger[a[0]] && klynger[a[1]];
    }));
    _results = [];
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      _ref1 = _ref[_k], a = _ref1[0], b = _ref1[1];
      _results.push({
        source: klynger[a],
        target: klynger[b]
      });
    }
    return _results;
  };

  update = function() {
    var handleResult, isPinned, klyngeId, _results;

    handleResult = function(localNodes, localLinks) {
      var child, node, _i, _j, _len, _len1, _ref;

      nodes = localNodes;
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        if (node.adhl) {
          _ref = node.adhl.slice(0, 5);
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            child = _ref[_j];
            if (klynger[child.klynge]) {
              localLinks.push([node.klynge, child.klynge]);
            }
          }
        }
      }
      links = makeLinks(localLinks);
      return draw();
    };
    _results = [];
    for (klyngeId in pinned) {
      isPinned = pinned[klyngeId];
      console.log(klyngeId, isPinned);
      if (isPinned) {
        _results.push(klyngeWalk(klyngeId, walkDepth, handleResult, handleResult));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  requestKlynge = function(klyngeId) {
    var klynge;

    if (klynger[klyngeId]) {
      klynge = klynger[klyngeId];
      if (!klynge.added) {
        nodes.push(klynge);
      }
      klynge.added = true;
      return;
    }
    if (graphLoading) {
      return;
    }
    graphLoading = true;
    return loadKlynge(klyngeId, function(klynge) {
      klynge.children = 0;
      graphLoading = false;
      return update();
    });
  };

  $(function() {
    var search;

    search = function() {
      var nodesOld, query, requestKlyngeOld;

      nodesOld = [];
      requestKlyngeOld = function(klyngeId, done) {
        return $.get("klynge/" + klyngeId, function(klynge) {
          var _ref;

          if (!klynge.faust) {
            return typeof done === "function" ? done() : void 0;
          }
          nodesOld.push(klynge);
          if ((_ref = klynge.adhl) != null) {
            _ref.sort(function(a, b) {
              return b.count * b.count / b.klyngeCount - a.count * a.count / a.klyngeCount;
            });
          }
          return $.get("faust/" + klynge.faust[0], function(faust) {
            klynge.title = faust.title;
            nodesOld = nodesOld.filter(function(klynge) {
              return klynge.adhl;
            });
            return typeof done === "function" ? done() : void 0;
          });
        });
      };
      query = ($("#query")).css({
        display: "none"
      }).val();
      location.hash = query;
      return $.get("search/" + query, function(result) {
        ($("#query")).css({
          display: "inline"
        }).val("");
        return async.map(result, function(faust, done) {
          return $.get("faust/" + faust, function(faust) {
            if (faust != null ? faust.klynge : void 0) {
              return requestKlyngeOld(faust != null ? faust.klynge : void 0, done);
            } else {
              return done();
            }
          });
        }, function() {
          var klynge, max, _i, _len;

          max = {
            count: 0
          };
          for (_i = 0, _len = nodesOld.length; _i < _len; _i++) {
            klynge = nodesOld[_i];
            if (max.count <= klynge.count) {
              max = klynge;
            }
          }
          initDraw();
          pinned[max.klynge] = true;
          return update();
        });
      });
    };
    ($("#search")).on("submit", function() {
      search();
      return false;
    });
    if (location.hash) {
      ($("#query")).val(location.hash.slice(1));
      search();
    }
    return ($("#search")).focus();
  });

}).call(this);
